<?php


/**
给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。



示例 1：

输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
示例 2：

输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。


提示：

2 <= cost.length <= 1000
0 <= cost[i] <= 999
 *
 * */
class Solution {

    /**
     * @param Integer[] $cost
     * @return Integer
     */
    function minCostClimbingStairs($cost) {
        if(empty($cost)) return 0 ;

        if(count($cost) == 1) return $cost[0];
        if(count($cost) == 2) return min($cost[0], $cost[1]);

        $cur = 0;
        $pre = 0;           //这里初始值为0的原因是，初始没有-1和-2下标，他们时开始的，没有下面累加的cost的值,这两值是下面累加的值的和
        for($i=2;$i<=count($cost);$i++){
            $next = min(($cost[$i-1] + $cur), ($cost[$i-2]+$pre));
            $pre = $cur;        //i-1赋值给i-2
            $cur = $next;       //当前最小的给i-1
        }

        return $cur;
    }
}

$a = new Solution();
//$cost = [1,100,1,1,1,100,1,1,100,1];
$cost = [10,15,20];
var_dump($a->minCostClimbingStairs($cost));


/*
 * 滚动数组思想：
 *1.前提概要
滚动数组是一种能够在动态规划中降低空间复杂度的方法，有时某些二维dp方程可以直接降阶到一维，在某些题目中甚至可以降低时间复杂度，是一种极为巧妙的思想。
简要来说就是通过观察dp方程来判断需要使用哪些数据，可以抛弃哪些数据，一旦找到关系，就可以用新的数据不断覆盖旧的数据量来减少空间的使用。
2.先以斐波那契数列为例
我们先以斐波那契数列来简单感受一下滚动数组的魅力，先上一段经典的代码（使用滚动数组）
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int a[3];
    a[0] = 1;
    a[1] = 1;
    for(int i = 1;i <= 35;i++)
    {
        a[2] = a[0] + a[1];
        a[0] = a[1];
        a[1] = a[2];
    }
    printf("%d\n",a[2]);
    return 0;
}

通过观察斐波那契数列方程 f ( n ) = f ( n − 1 ) + f ( n − 2 ) f(n) = f(n-1) + f(n-2)f(n)=f(n−1)+f(n−2)，
我们可以发现，实际上只需要前两个递推的数求和即可，于是我们可以使用数组的前三个位置来分别存贮数据，再用递推得到的新数据将旧数据覆盖。
这样我们本来需要用三十多个位置的数组，最终却只用了三个位置，大大减少了空间复杂度。对于某些只需要最终答案的题目，我们可以抛弃掉当中一些不必要存贮的数据，来减少空间的使用。

 * */
